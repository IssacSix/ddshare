[TOC]

## 前端模块化

### 为什么前端需要模块化？

​	个人认为，前端的模块化是一个项目工程化，规范化的必然趋势，至少作为前端小菜鸟的我是这么踩着坑一步一步过来的，所以 玉伯 [《前端模块的开发的意义》](https://github.com/seajs/seajs/issues/547) 是深深的写进了我的心里。。。

#### 现象描述

将一个个通用的、底层的功能抽象出来，独立成一个工具函数，是一个猿的基本习惯跟觉悟

```
1.创建一个util.js
2.开始造轮子啦
	function each () {
      // todo
	}
	
	function log () {
      // todo
	}
3.感觉自己棒棒哒 ：）
```

一周，两周，一个月，看着utils逐步健全起来，深表欣慰，群众的呼声也是愈来越高：丁丁好牛逼！丁丁好厉害！

日子一天天的过去，团队人数增加，项目越来越多，同名污染越来越严重。咋办？用命名空间来解决吧

```
var org = {};
org.CoolSite = {};
org.CoolSite.Utils = {};

org.CoolSite.Utils.each = function (arr) {
  // todo
};

org.CoolSite.Utils.log = function (str) {
  // todo
};
```

oh my gold！ 程序员何苦为难程序员，能活着好好写代码已经是一件不容易的事，就为了调一个方法，居然还要记着么长的名字，如果你一人同时负责三个以上的项目，这，，，已经开始整理行李了。

于是 **require.js  common.js** 模块化神器孕育而生了。

#### 玉伯的文章最后总结提到的模块化的意义

1. **模块的版本管理** 。通过别名等配置，配合构建工具，可以比较轻松地实现模块的版本管理。
2. **提高可维护性** 。模块化可以让每个文件的职责单一，非常有利于代码的维护。Sea.js 还提供了 nocache、debug 等插件，拥有在线调试等功能，能比较明显地提升效率。
3. **前端性能优化** 。Sea.js 通过异步加载模块，这对页面性能非常有益。Sea.js 还提供了 combo、flush 等插件，配合服务端，可以很好地对页面性能进行调优。
4. **跨环境共享模块** 。CMD 模块定义规范与 Node.js 的模块规范非常相近。通过 Sea.js 的 Node.js 版本，可以很方便实现模块的跨服务器和浏览器共享。



### 前端模块化的工具

#### RequireJs

1. 说起Require 那不得不提一个规范 =>  [AMD 中文版](https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88))

2. **Require 与 AMD 的关系 **

   require 作为前端一个模块化的工具，那么以什么规范准则来定义一个个异步模块呢？回答：AMD

3. 对AMD不太了解，也不常用，这里举一个简单的栗子，详细可以查阅以上链接

   ```
   define("alpha", ["require", "exports", "beta"], function (require, exports, beta) {
      exports.verb = function() {
          return beta.verb();
          // 或者:
          //return require("beta").verb();
      }
   });
   ```

   ​

#### CommonJS

1. 与CommonJS对应的规范 =>  [CMD 中文版](https://github.com/seajs/seajs/issues/242)

   简单的说 就是module.exports 导出来的变量， require来引入其他的变量到当前的函数作用域中

2. 同理CommonJS 与 CMD 的关系 等同与 Require 与 AMD之间的关系

3. 定义规范 define `define(id?, deps?, factory)`

   ```
   define('hello', ['jquery'], function(require, exports, module) {
     // 模块代码
   });

   id 和 deps 参数可以省略。省略时，可以通过构建工具自动生成

   ```

4. 举个栗子

   ```
   define(function(require, exports) {

     // 获取模块 a 的接口
     var a = require('./a');

     // 调用模块 a 的方法
     a.doSomething();
     
     module.exports = {
       foo: 'bar',
       doSomethingElse: function() {}
     }
     
   });
   ```


5. 另外要特殊说明的一点，经常听到或者看到网上一大片，node中的 **module.exports 与 exports 究竟有什么区别**?

   简单的说， module.exports 是 exports的覆盖， exports仅仅是module.exports的一个引用

   来一个🌰

   ```
   modules.exports.age = 18;
   exports.name = 'dingding'

   var person = require('./test')
   console.log('%s is %s', person.name, person.age) // dingding is 18
   ```

   再来一个🌰

   ```
   module.exports = 'wtf'
   module.exports.age = 18
   exports.name = 'dingding'

   or 

   module.exports.age = 18
   exports.name = 'dingding'
   module.exports = 'wtf'

   var person = require('./test')
   console.log(person) 	// wtf
   console.log('%s is %s', person.name, person.age) // name and age is not defined
   ```



#### AMD 与 CMD 的异同

参考博文 [《与RequireJS》](https://github.com/seajs/seajs/issues/277)

##### 相同之处

都是模块加载器，倡导模块化开发的理念

##### 不同之处

1. 定位差异：RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 环境中。
2. 遵循的规范不同。玉伯认为，return 还是 module.exports，存粹是个人习惯的区分，没有优劣
3. 核心差异  =>  预加载 vs 懒加载

* AMD 预加载 define即执行   **提前执行  依赖前置**
* CMD 懒加载 require时才执行   **延迟执行  依赖就近**

|      | AMD         | CMD            |
| :--- | ----------- | -------------- |
| 加载   | define 加载完成 | define 加载完成    |
| 执行   | define 即执行  | 运行到require时才执行 |
| 总结   | 提前执行  依赖前置  | 延迟执行  依赖就近     |



参考 [《全栈大神的模块化解析》](https://github.com/highsea/cnblog/blob/master/%E5%9B%9E%E9%A1%BE%EF%BC%9A%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8CAMD%E3%80%81CMD%E8%A7%84%E8%8C%83%EF%BC%88%E5%85%A8%EF%BC%89.md)	





