[TOC]

## 前后端分离的思考与设计

### 前后端分离

#### 为什么要前后端分离（需求来源）：

1. **为了提升开发效率**	

   随着不同终端(Pad/Mobile/PC)的兴起，对开发人员的要求越来越高，纯浏览器端的响应式已经不能满足用户体验的高要求，我们往往需要针对不同的终端开发定制的版本。

   ​**后端负责业务/数据接口**，

   ​**前端负责展现/交互逻辑**

   ​Thus, 对于同一份数据接口，我们可以定制开发多个版本。

2. **职责分离**

   发版本，上线，前后端可以保持独立，互不干涉，对的人做对的事

#### 什么是前后端分离

从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景：

- 前端：负责View、Controller层面
- 后端：只负责Model，业务处理/数据等。

#### 前后端分离方案

##### 后端MVC时代

- 后端：一切尽在掌控中
- 前端：那么我呢  => 套模版
- 后果：
  - 前端代码越来越复杂，代码中充满了约定，沟通成本高
  - js css  依赖最终产出的HTML
  - 有的业务在前端，有的在Model，更多的在View层
  - 前端写页面，后端套页面，后端同学仍然要写HTML
  - 前端依赖服务端的**开发环境**，在服务端view高度耦合

##### mv*时代

经历了第一次前后端分离发展，我们迎来了mv*时代，后端只提供数据，剩下的前端自己搞，从此前端踏上了苦逼的不归路。

业界满坑满谷的优秀方案

Backbone, EmberJs, AagularJs, React, tec, Vue

- 前端:  mvc

  - view: js template 
  - model: js object ( json )
  - controller: js 该怎么控制怎么控制

- 后端：mvc

- 结果：

  - 能看到的好处：前后端职责清晰了

  | 后端                | 前端                |
  | ----------------- | ----------------- |
  | 提供数据              | 接受数据，返回数据         |
  | 处理业务逻辑            | 处理渲染逻辑            |
  | Server-side MVC架构 | Client-side MV*架构 |
  | 代码跑在服务器上          | 代码跑在浏览器上          |

  - the problems
    - 路由问题：前端的路由可能在后端没有 （这可能是个潜在的问题）
    - 渲染，取值都在客户端进行，有性能问题  （考验前端性能优化的程度）
    - 需要等待资源奇，才能进行，短暂白屏与闪动 （可优化，不是问题，发起异步请求）
    - seo不易 （ssh）

##### nodeJS的时代

浏览器 + node 撑起大前端

| java   | node      | 浏览器         |
| ------ | --------- | ----------- |
| 服务层    | 跑在服务器上的js | 跑在浏览器上的js   |
| 提供数据接口 | 转发数据，串联服务 | css js 加载执行 |
| 维持数据稳定 | 路由设计，控制逻辑 | DOM操作       |
| 封装业务逻辑 | 渲染页面，体验优化 | 任何前端框架与     |
|        | 更多的可能...  | 共用模版、路由     |

接口性能优化，拆分大接口成为独立的小接口，并发请求，改串行未并行，大幅缩短请求时间。

页面渲染优化

- 前后端共享模版
- 首屏服务器渲染
- 次屏浏览器渲染
- 局部刷新浏览器渲染

#### 分离实现方案: 基于NodeJS"全栈"式开发

典型成功案例：淘宝《中途岛》

在录音宝 spa模式之下，已经基本实现后端提供数据，前端控制View跟页面的交互的情况下，我们是否可以根据现在项目的需要，进一步实现

![pic](https://raw.githubusercontent.com/IssacSix/gitImags/master/201712.11/node.png)

